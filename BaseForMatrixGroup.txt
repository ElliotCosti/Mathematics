/*
RandomSpace := function (d, q, k) 
V := VectorSpace (GF(q), d); 
U := sub < V | [Random (V): i in [1..k]]>; 
return U; 
end function; 

d := 20; q := 17;
S := [RandomSpace (d, q, Random ([1..d div 2])): k in [1..d div 3]]; 
U := RandomSpace (d, q, Random ([1..d div 2])); 
A,B := StabiliserOfSpaces (S); 
H := sub < GL(d, q) | B>; 
F := GF(q);

V := VectorSpace (GF(q), d); 
_, CB := PInvariantFlag(V, H);
X := [H.i^CB : i in [1..Ngens(H)]];
SLP := WordGroup(sub<GL(d, F)|X>);
XSLP := [SLP.i : i in [1..#X]];

*/


PInvariantFlag := function (V, X)

    F := BaseRing (X);
    p := #F;
    d := Degree (X);
    MA := MatrixAlgebra (F, d);
    t := Ngens (X);
    Y := [MA!X.j : j in [1..t]];
/* the coercion of the generators of the p-group into the matrix algebra */

    /* clumsy handling of trivial case */
    if t eq 0 then
       B := Basis (V);
       d := #B;
       W := [sub < V | [B[j] : j in [i..d]]> : i in [1..d]];
/* take the set of subspaces to be those generated by the last (d-i) vectors
of V */
       Append (~W, sub < V | >);
    else
       W := [V]; // W starts a list containing just the whole space
       k := 1;
       I := Identity (MA);
       while Dimension (W[k]) ne 0 do
          k +:= 1;
          W[k] := &+[W[k-1] * (Y[j] - I): j in [1..t]];
/* this line forms the next term in the sequence by taking the previous
space and multiplying
it by all the generators of the p-group minus the identity */

       end while;
    end if;

    flag := [];
    for i in [1..#W - 1] do
       F, phi := quo < W[i] | W[i + 1] >;
/* F is the quotient space and phi is the natural map. For example in the
trivial case, we go from a subspace
with n vectors over a subspace with n-1 vectors to the full vector space of
dimension 1. */

       BF := Basis (F);
       FB := [BF[j] @@ phi : j in [1..Dimension (F)]];
/* the pre-image of each basis vector back up in W[i] */
       flag cat:= FB; // adds FB to flag
    end for;

    Spaces := [sub < V | >] cat
            [sub <V | [flag[i]: i in [#flag..j by -1]]>: j in [#flag..1 by
-1]];
/* the collection of spaces made up of the last j vectors in flag. */
    Reverse (~Spaces);
/* reverses the order so that the full space is first and the empty space is
last. */

    CB := (GL (d, p) ! &cat[Eltseq (f): f in flag])^-1;
/* taking the vectors of flag and turning them into a matrix. E.g. [1, 0]
and [0, 1]
becomes the 2 by 2 identity matrix. */

    return flag, CB, Spaces;

end function;

VectorExtract := function(j, M);

   v := [];
   n := Degree(M);
   q := #BaseRing(M);
   for i in [1..n-j] do
      Append(~v, M[i, i+j]);
   end for;
   v := VectorSpace(GF(q), n-j)!v;

   return v;

end function;

MatrixWeight := function(M);

   n := Degree(M);

   k := 0;
   for z in [1..n-1] do
      for i in [1..n-z] do
         if M[i, i+z] ne 0 then k := z; break; end if;
      end for;
      if k ne 0 then break; end if;
   end for;
   F := BaseRing(M);
   p := Characteristic(F);
   e := Degree(F);

   v := VectorExtract(k, M);
   d := Depth(v);
   V := VectorSpace(GF(p), e);
   dd := Depth(V!Eltseq(v[d]));
   return [k, d, dd];

end function;

/* input to this algorithm must have X (the generators of the p-group) in upper uni triangular form */

/*

Strip := function(X)

d := Dimension(X[1]);
A := [];
for i in [1..d-1] do
   Append(~A, []);
end for;

globalflag := false;

for i in [1..d-1] do
end for;

end function;

d := Dimension(X[1]);
F := BaseRing(X[1]);
a := [];
V := VectorSpace(F, d-1);
for x in X do
   Append(~a, V!VectorExtract(1, x));
end for;
a := sub<V|a>;
B := [a.i : i in [1..Ngens(a)]];

c := [];
for i in [1..Ngens(a)] do
   Append(~c, Coordinates(a, Basis(a)[i]));
end for;

*/

FindIncreasePower := function(weight, h, s);
   j0 := weight[1];
   j1 := weight[2];
   j2 := weight[3];

   alpha := -Eltseq(h[j1, j0 + j1])[j2]/Eltseq(s[j1, j0 + j1])[j2];
   
   alpha := IntegerRing()!alpha;
   
   return alpha;
end function;

IncreaseDepth := function(s, S, SSLP, min);
     j0 := min[1];
     j1 := min[2];
     j2 := min[3];
     identity := Id(Parent(s));
     X := [];
     XSLP := [];
       for h in S do
          if h ne s then
             if MatrixWeight(h) eq [j0, j1, j2] then
                beta := FindIncreasePower ([j0, j1, j2], h, s);
                hh := h * s^beta;
                hhslp := SSLP[Position(S, h)] * SSLP[Position(S, s)]^beta;
             else
                hh := h;
                hhslp := SSLP[Position(S, h)];
             end if;
             if hh ne identity then
                Append (~X, hh);
                Append (~XSLP, hhslp);
             end if;
          end if;
       end for;

      return X, XSLP;
end function;

PChiefSeriesGenerators := function(X, XSLP);

   if #X eq 0 then
      return [], [];
   end if;

   Y := X;
   YSLP := XSLP;
   B := [];
   BSLP := [];
   p := Characteristic(BaseRing(X[1]));
   identity := Id(Parent(X[1]));

   depth := [MatrixWeight(g) : g in X]; 
   depth1 := [depth[x, 1] : x in [1..#depth]];
   j0 := Minimum (depth1);
   depth2 := [];
   for x in [1..#X] do
      if depth[x, 1] eq j0 then
         Append(~depth2, depth[x, 2]);
      end if;
   end for;
   j1 := Minimum (depth2);
   depth3 := [];
   for x in [1..#X] do
      if (depth[x, 1] eq j0) and (depth[x, 2] eq j1) then
         Append(~depth3, depth[x, 3]);
      end if;
   end for;
   j2 := Minimum (depth3);

   while #Y ne 0 do
      g := Y[Position (depth, [j0, j1, j2])];
      gslp := YSLP[Position (depth, [j0, j1, j2])];
      Append(~B, g);
      Append(~BSLP, gslp);

      Y, YSLP := IncreaseDepth(g, Y, YSLP, [j0, j1, j2]);
      if g^p ne identity then
         Append(~Y, g^p);
         Append(~YSLP, gslp^p);
      end if;
      for x in X do
         if g^-1 * x^-1 * g * x ne identity then
            Append(~Y, g^-1 * x^-1 * g * x);
            xslp := XSLP[Position(X, x)];
            Append(~YSLP, gslp^-1 * xslp^-1 * gslp * xslp); 
         end if;
      end for;

      if #Y eq 0 then break; end if;

      depth := [MatrixWeight(g) : g in Y]; 
      depth1 := [depth[x, 1] : x in [1..#depth]];
      j0 := Minimum (depth1);
      depth2 := [];
      for x in [1..#Y] do
         if depth[x, 1] eq j0 then
            Append(~depth2, depth[x, 2]);
         end if;
      end for;
      j1 := Minimum (depth2);
      depth3 := [];
      for x in [1..#Y] do
         if (depth[x, 1] eq j0) and (depth[x, 2] eq j1) then
            Append(~depth3, depth[x, 3]);
         end if;
      end for;
      j2 := Minimum (depth3);

   end while;

   return B, BSLP;

end function;


/*
B := PChiefSeriesGenerators(X, XSLP);
BB := sub<GL(d, F)|B>;

for i in [1..#B] do
   i;
   blob := sub<BB|[BB.j : j in [#B-1..#B]]>;
   blib := sub<BB|[BB.j : j in [#B-2..#B]]>;
   IsNormal(BB, blob);
   IsNormal(blib, blob);
end for;

*/

/*
RandomSpace := function (d, q, k) 
V := VectorSpace (GF(q), d); 
U := sub < V | [Random (V): i in [1..k]]>; 
return U; 
end function; 

for d in [6..10] do
for q in [2,3,4,5,7,8,9,11,13,16,17,19,23,25, 64, 81, 128, 243] do
for i in [1..10] do 
d, q, i;

S := [RandomSpace (d, q, Random ([1..d div 2])): k in [1..d div 3]]; 
U := RandomSpace (d, q, Random ([1..d div 2])); 
A,B := StabiliserOfSpaces (S); 
H := sub < GL(d, q) | B>; 
F := GF(q);

V := VectorSpace (GF(q), d); 
_, CB := PInvariantFlag(V, H);
X := [H.i^CB : i in [1..Ngens(H)]];
SLP := WordGroup(sub<GL(d, F)|X>);
XSLP := [SLP.i : i in [1..#X]];

B := PChiefSeriesGenerators(X, XSLP);
BB := sub<GL(d, F)|B>;
XX := sub<GL(d, F)|X>;

bb := Ngens(BB);
for k in [1..bb] do
   blob := sub<BB|[BB.j : j in [bb-1..bb]]>;
   blib := sub<BB|[BB.j : j in [bb-2..bb]]>;
   assert IsNormal(BB, blob);
   assert IsNormal(blib, blob);
end for;

// B is a set of elements that are words in elements of X
// so if the groups that they generate have the same order
// then they must be the same group

// assert #XX eq #BB;

end for; end for; end for;

*/


