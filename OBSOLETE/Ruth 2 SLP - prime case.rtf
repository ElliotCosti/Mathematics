{\rtf1\ansi\ansicpg1252\uc1\deff0\stshfdbch0\stshfloch0\stshfhich0\stshfbi0\deflang2057\deflangfe2057{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f36\froman\fcharset238\fprq2 Times New Roman CE;}{\f37\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f39\froman\fcharset161\fprq2 Times New Roman Greek;}
{\f40\froman\fcharset162\fprq2 Times New Roman Tur;}{\f41\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f42\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f43\froman\fcharset186\fprq2 Times New Roman Baltic;}
{\f44\froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f56\fmodern\fcharset238\fprq1 Courier New CE;}{\f57\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f59\fmodern\fcharset161\fprq1 Courier New Greek;}
{\f60\fmodern\fcharset162\fprq1 Courier New Tur;}{\f61\fmodern\fcharset177\fprq1 Courier New (Hebrew);}{\f62\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f63\fmodern\fcharset186\fprq1 Courier New Baltic;}
{\f64\fmodern\fcharset163\fprq1 Courier New (Vietnamese);}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;
\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang2057\langfe2057\cgrid\langnp2057\langfenp2057 \snext0 Normal;}{\*\cs10 \additive \ssemihidden Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1024\langfe1024\cgrid\langnp1024\langfenp1024 \snext11 \ssemihidden Normal Table;}}{\*\rsidtbl \rsid1329637\rsid3674621\rsid6894426}
{\*\generator Microsoft Word 10.0.2627;}{\info{\author  }{\operator  }{\creatim\yr2006\mo11\dy14\hr12\min15}{\revtim\yr2006\mo11\dy14\hr23\min25}{\version4}{\edmins2}{\nofpages9}{\nofwords1426}{\nofchars8131}{\*\company  }{\nofcharsws9538}{\vern16437}}
\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3\jcompress\viewkind1\viewscale100\nolnhtadjtbl\rsidroot3674621 \fet0\sectd 
\linex0\sectdefaultcl\sftnbj {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4
\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}
{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain \ql \li0\ri0\sl288\slmult0\nowidctlpar
\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\faauto\rin0\lin0\itap0 \fs24\lang2057\langfe2057\cgrid\langnp2057\langfenp2057 {\f2\fs20\cf1\insrsid3674621 
/* depths is list containing depth of vectors in U;
\par     w is vector; U basis for subspace in canonical form;
\par     return weight of w wrt \{w, U\} */
\par 
\par SubspaceDepth:= function (depths, w, UU)
\par 
\par     n := #depths - Dimension (UU);
\par     d := Degree (UU);
\par     F := BaseRing (UU);
\par     V := VectorSpace (F, d);
\par     U := Basis (UU);
\par 
\par     dw := Depth (w);
\par     while dw in depths do
\par        pos := Position (depths, dw) - n;
\par        w := w - (w[dw] / U[pos][dw]) * U[pos];
\par        dw := Depth (w);
\par     end while;
\par 
\par     if dw ne 0 then return dw; else return d + 1; end if;
\par 
\par end function;
\par 
\par /* echelonise v wrt UU */
\par 
\par EcheloniseVector := function (v, depths, UU)
\par     U := Basis (UU);
\par     j := 0;
\par     for i in [1..#depths] do
\par        if IsDefined (depths, i) eq true then
\par           j +:= 1;
\par           alpha := v[depths[i]];
\par           if alpha ne 0 then
\par              v := v - (alpha / U[j][depths[i]]) * U[j];
\par           end if;
\par        end if;
\par     end for;
\par     return v;
\par end function;
\par 
\par /* find increasing chain of subspaces of V fixed under X */
\par 
\par PInvariantFlag := function (V, X)
\par 
\par     F := BaseRing (X);
\par     p := #F;
\par     d := Degree (X);
\par     MA := MatrixAlgebra (F, d);
\par     t := Ngens (X);
\par     Y := [MA!X.j : j in [1..t]];
\par 
\par     /* clumsy handling of trivial case */
\par     if t eq 0 then
\par        B := Basis (V);
\par        d := #B;
\par        W := [sub < V | [B[j] : j in [i..d]]> : i in [1..d]];
\par        Append (~W, sub < V | >);
\par     else
\par        W := [V];
\par        k := 1;
\par        I := Identity (MA);
\par        while Dimension (W[k]) ne 0 do
\par           k +:= 1;
\par           W[k] := &+[W[k-1] * (Y[j] - I): j in [1..t]];
\par        end while;
\par     end if;
\par 
\par     flag := [];
\par     for i in [1..#W - 1] do
\par        F, phi := quo < W[i] | W[i + 1] >;
\par        BF := Basis (F);
\par        FB := [BF[j] @@ phi : j in [1..Dimension (F)]];
\par        flag cat:= FB;
\par     end for;
\par 
\par     Spaces := [sub < V | >] cat
\par             [sub <V | [flag[i]: i in [#flag..j by -1]]>: j in [#flag..1 
\par by -1]];
\par     Reverse (~Spaces);
\par 
\par     CB := (GL (d, p) ! &cat[Eltseq (f): f in flag])^-1;
\par     return flag, CB, Spaces;
\par 
\par end function;
\par 
\par /* return generating set which determines (decreasing) chief series 
\par subs
\par     for matrix group S */
\par 
\par BaseForMatrixGroup := function (S: Verify := true)
\par 
\par     if Type (S) eq GrpMat then
\par        d, F := BasicParameters (S);
\par     elif #S gt 0 then
\par        d := Nrows (Rep (S));
\par        F := BaseRing (Parent (Rep (S)));
\par        S := sub < GL (d, F) | S >;
\par     else
\par        return [], [];
\par     end if;
\par 
\par     T, phi := PCGroup (S);
\par     CS := ChiefSeries (T);
\par     t := NPCgens (T);
\par     gens := [CS[i].1 : i in [1..t]];
\par     X := [gens[i] @@ phi: i in [1..t]];
\par     if Verify then
\par        subs := [sub < S | [X[j] : j in [t..i by -1]]> : i in [t..1 by 
\par -1]];
\par        O := [#subs[i] : i in [1..#subs]];
\par        if #O gt 1 then
\par           assert \{IsPrime (O[i + 1] div O[i]) : i in [1..#O - 1]\} eq 
\par \{true\};
\par           assert \{IsNormal (S, subs[i]) : i in [1..#O - 1]\} eq \{true\};
\par        end if;
\par     end if;
\par 
\par     return X, sub <GL(d, F) | X>;
\par 
\par end function;
\par 
\par /* depth of u - u * g */
\par 
\par RelativeVectorDepth := function (u, g)
\par     d := Depth (u - u * g);
\par }\pard \ql \li720\ri0\sl288\slmult0\nowidctlpar\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\faauto\rin0\lin720\itap0 {\f2\fs20\cf1\insrsid3674621 
return d eq 0 select Degree (u) + 1 else d; // if the left hand side is true, do the first else to the second
\par }\pard \ql \li0\ri0\sl288\slmult0\nowidctlpar\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\faauto\rin0\lin0\itap0 {\f2\fs20\cf1\insrsid3674621 end function;
\par 
\par FindMultiple := function (p, u, i, k, h)
\par 
\par     if exists (alpha) \{alpha : alpha in [1..p - 1] |
\par                 RelativeVectorDepth (u, k * h^alpha) gt i\} eq false 
\par then
\par        error "error in FindMultiple";
\par     end if;
\par 
\par     return alpha;
\par 
\par end function;
\par 
\par BFindMultiple := function (depths, p, u, i, k, h, U)
\par 
\par     if exists (alpha) \{alpha : alpha in [1..p - 1] |
\par        SubspaceDepth (depths, u - u * (k * h^alpha), U) gt i\} eq false 
\par then
\par        error "error in FindMultiple";
\par     end if;
\par 
\par     return alpha;
\par 
\par end function;
\par 
\par VectorMultiple := function (p, u, h, i)
\par 
\par     beta := 0;
\par     while u[i] ne 0 and beta lt p do
\par        beta +:= 1;
\par        u := u * h;
\par     end while;
\par 
\par     if beta eq p then error "error in VectorMultiple"; end if;
\par 
\par     return beta, u;
\par end function;
\par 
\par SpaceMultiple := function (p, u, depths, subU, h, i)
\par     beta := 0;
\par     u := EcheloniseVector (u, depths, subU);
\par     while u[i] ne 0 do
\par        u := u * h;
\par        beta +:= 1;
\par        if beta gt p then error "error in SpaceMultiple"; end if;
\par        u := EcheloniseVector (u, depths, subU);
\par     end while;
\par 
\par     return beta, u;
\par 
\par end function;
\par 
\par /* return canonical form v for u, an element x in P such that u * x = 
\par v,
\par     and the stabiliser in P of v */
\par 
\par VectorCF := function (X, XSLP, u)
\par 
\par     d := Degree (u); F := BaseRing (Parent (u));
\par     if #X eq 0 then
\par        return u, Identity (GL(d, F)), Identity(SLPGroup(0)), X;
\par     end if;
\par 
\par     p := #F;
\par     d := Nrows (X[1]);
\par 
\par     v := u;
\par     depth := [RelativeVectorDepth (v, g) : g in X];
\par     j0 := Minimum (depth);
\par 
\par     x := X[1]^0;
\par     xslp := Identity(Parent(XSLP[1])); // the identity of the SLP.
\par     Y := X;
\par     YSLP := XSLP;
\par 
\par     while (j0 lt d + 1) do
\par        g := X[Position (depth, j0)];
\par        gslp := XSLP[Position (depth, j0)];
\par        alpha, v := VectorMultiple (p, v, g, j0);
\par        x := x * g^alpha;
\par        xslp := xslp * gslp^alpha;
\par        Y := [];
\par        YSLP := [];
\par        for h in X do
\par           if h ne g then
\par              if RelativeVectorDepth (v, h) eq j0 then
\par                 beta := FindMultiple (p, v, j0, h, g);
\par                 hh := h * g^beta;
\par                 hhslp := XSLP[Position(X, h)] * gslp^beta;
\par             else
\par                 hh := h;
\par                 hhslp := XSLP[Position(X, h)];
\par              end if;
\par              Append (~YSLP, hhslp);
\par              Append (~Y, hh);
\par           end if;
\par        end for;
\par        X := Y;
\par        XSLP := YSLP;
\par        if #X eq 0 then break; end if;
\par        depth := [RelativeVectorDepth (v, g) : g in X];
\par        j0 := Minimum (depth);
\par     end while;
\par 
\par     return v, x, xslp, X, XSLP;
\par 
\par end function;
\par 
\par NextSubspaceCF := function (X, XSLP, V, UU, depths, index)
\par 
\par     U := Basis (UU);
\par     d := Degree (UU);
\par     p := #BaseRing (UU);
\par     t := #U;
\par     v := U[index];
\par     subU := sub < V | [U[i] : i in [index + 1..t]]>;
\par 
\par     depth := [SubspaceDepth (depths, v - v * g, subU) : g in X];
\par     j0 := Minimum (depth);
\par 
\par     x := X[1]^0;
\par     xslp := Identity(Parent(XSLP[1]));
\par     Y := X;
\par     YSLP := XSLP;
\par 
\par     while (j0 lt d + 1) do
\par        g := X[Position (depth, j0)];
\par        gslp := XSLP[Position (depth, j0)];
\par        v := EcheloniseVector (v, depths, subU);
\par        alpha, v := SpaceMultiple (p, v, depths, subU, g, j0);
\par        x := x * g^alpha;
\par        xslp := xslp * gslp^alpha;
\par        Y := [];
\par        YSLP := [];
\par        for h in X do
\par           if h ne g then
\par              if SubspaceDepth (depths, v - v * h, subU) eq j0 then
\par                 beta := BFindMultiple (depths, p, v, j0, h, g, subU);
\par                 hh := h * g^beta;
\par                 hhslp := XSLP[Position(X, h)] * gslp^beta;
\par              else
\par                 hh := h;
\par                 hhslp := XSLP[Position(X, h)];
\par              end if;
\par              Append (~Y, hh);
\par              Append (~YSLP, hhslp);
\par           end if;
\par        end for;
\par        X := Y;
\par        XSLP := YSLP;
\par        if #X eq 0 then break; end if;
\par        depth := [SubspaceDepth (depths, v - v * g, subU) : g in X];
\par        j0 := Minimum (depth);
\par     end while;
\par 
\par     UU := UU * x;
\par     depths[index] := Depth (v);
\par 
\par     return x, xslp, UU, depths, X, XSLP;
\par 
\par end function;
\par 
\par /* determine canonical form for U under action of X;
\par     return canonical form UC, element trans where U^trans = UC,
\par     and stabiliser in X of UC */
\par 
\par SubspaceCF := function (X, XSLP, U)
\par 
\par     d := Degree (U); F := BaseRing (U);
\par 
\par     if #X eq 0 then
\par         return U, Identity (GL(d, F)), Identity(SLPGroup(0)), X;
\par     end if;
\par 
\par     V := VectorSpace (F, d);
\par 
\par     UB := Basis (U);
\par     t := #UB;
\par     CF, trans, transslp, X, XSLP := VectorCF (X, XSLP, UB[t]);
\par     U := U * trans;
\par     UB := Basis (U);
\par     depths := [];
\par     depths[t] := Depth (UB[t]);
\par     for i in [t - 1..1 by -1] do
\par        if #X eq 0 then break; end if;
\par        temp, tempslp, U, depths, X, XSLP := NextSubspaceCF (X, XSLP, V, U, depths, i);
\par        trans *:= temp;
\par        transslp *:= tempslp;
\par     end for;
\par 
\par     return U, trans, transslp, X, XSLP;
\par 
\par end function;
\par 
\par /* S is a p-group; U is a subspace of natural module;
\par     return canonical form UC for U, matrix trans where
\par     U^trans = UC, and generators for stabiliser in S of UC;
\par 
\par     if ComputeBase is false, we assume that the generators
\par     of S are a decreasing chief series for S */
\par 
\par PGroupStabiliser := function (S, U, SLP: ComputeBase := false)
\par 
\par     d := Degree (U); F := BaseRing (U);
\par     S := sub < GL (d, F) | S >;
\par     if Ngens (S) eq 0 then return U, Identity (GL(d, F)), Identity(SLPGroup(0)), S, 1; end if;
\par 
\par     if ComputeBase then _, S := BaseForMatrixGroup (S); end if;
\par 
\par     V := VectorSpace (F, d);
\par     flag, CB := PInvariantFlag (V, S);
\par     S := [S.i^CB : i in [1..Ngens (S)]];
\par     XSLP := [];
\par     for j in [1..#S] do
\par        Append(~XSLP, SLP.j); // need to modify the entries in the SLP to match the changes in X
\par     end for;
\par     CBinv := CB^-1;
\par     U := U^CB;
\par     UC, trans, transslp, Y, YSLP := SubspaceCF (S, XSLP, U);
\par     p := #F; length := p^(#S - #Y);
\par     Trans := CB * trans; TransInv := Trans^-1;
\par     return UC^CBinv, Trans * CBinv, transslp,
\par            sub <GL (d, F) | [Y[i]^TransInv : i in [1..#Y]]>, length;
\par 
\par end function;
\par 
\par function UnipotentStabiliser (G, U)
\par 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20\cf1\insrsid3674621 SLP := SLPGroup(Ngens(G)); // define an SLP group on the generators of the p-group. We want the algorithm to return trans as an SLP in these generators.
\par }\pard \ql \li0\ri0\sl288\slmult0\nowidctlpar\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\faauto\rin0\lin0\itap0 {\f2\fs20\cf1\insrsid3674621 
    cf, trans, transslp, stab := PGroupStabiliser (G, U, SLP: ComputeBase := }{\f2\fs20\cf1\insrsid1329637 false}{\f2\fs20\cf1\insrsid3674621 );
\par     return stab, cf, trans, transslp;
\par 
\par end function;
\par }{\f2\insrsid3674621 
\par }}