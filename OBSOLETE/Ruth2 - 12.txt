/* We redefine depth to cope with non prime fields. The Depth Plus of a
vector consists of a pair. The first entry is the vector's depth in the old
sense. If you consider an element of the prime field as a polynomial with
the primitive element (w) as the indeterminant, then the field can be
considered as a vector space of the prime field; the coefficients of the
powers of w being the entries in the vector. For example, in the field 5^3,
the element 2 + 4w + 3w^2 would map to the vector (2 4 3). If the depth of
the vector v is i, then the second entry in Depths Plus is the depth of v[i]
considered as a vector in this way. For example, the vector over the field
of 125 elements [0 0 w 1] has Depth Plus of [3, 2] as 3 is the depth in the
old sense and w corresponds to the vector (0 1 0), which has depth 2. */

DepthPlus:= function(v)

    if Depth(v) eq 0 then return [0, 1]; end if;
    F := BaseRing(v);
    _, incl:= VectorSpace(F, PrimeField(F));
    return [Depth(v), Depth(incl(v[Depth(v)]))];

end function;

/* depths is list containing depth of vectors in UU; w is vector; UU is a
subspace of the original space where each basis element is in canonical
form; return weight of w wrt {w, UU}. What this means is, if the depth of w
is not equal to the depth of any other basis vector of UU, then the depth of
w wrt UU is DepthPlus(w). If, however, the depth of w is equal to another
basis vector in UU, then the depth of w wrt to UU is DepthPlus(w) minus
linear combinations of these basis vectors. The multiple of the basis vector
that you should be subtracted is such that u_m has coefficient 0 in w
-a_1*u_1 -..-a_m*u_m. */

SubspaceDepth:= function (depths, w, UU)

    n := #depths - Dimension (UU); /* depths will be of the same length as
the dimension of the input subspace. The first n entries of depths are as
yet undefined. They become defined as further basis elements of the input
subspace are canonised. */
    d := Degree (UU); // the length of the vectors of UU
    F := BaseRing (UU);
    V := VectorSpace (F, d);
    U := Basis (UU);
    temp := [];
    for i in [n+1..#depths] do
       temp[i] := depths[i][1];
   end for;
   depths := temp;

    _, incl:= VectorSpace(F, PrimeField(F));

    dw := DepthPlus(w);
    while dw[1] in depths do
       pos := Position (depths, dw[1]) - n; /* pos is the position in the
defined portion of the depths vector with depth equal to that of w. */
       w := w - w[dw[1]] / U[pos][dw[1]] * U[pos];
/* in the above, w[dw[1]] is the first non zero entry in w and U[pos][dw[1]]
is the first non zero entry in U[pos] since both have the same depth. Hence
this process kills the dw[1]-th position in w. */
       dw := DepthPlus(w);
    end while;

    if dw ne [0, 1] then return dw; else return [d + 1, 1]; end if;
/* second bit is the zero vector case */

end function;

/* echelonise v wrt UU. UU and depths as above. It takes the vector v, and
kills as many places as it can within the vector by subtracting suitable
multiples of the other basis vectors of UU from it. */

EcheloniseVector := function (v, depths, UU)
    U := Basis (UU);
    j := 0;
    for i in [1..#depths] do
       if IsDefined (depths, i) eq true then
          j +:= 1;
          alpha := v[depths[i][1]];
          if alpha ne 0 then
             v := v - (alpha / U[j][depths[i][1]]) * U[j];
          end if;
       end if;
    end for;
    return v;
end function;

/* find increasing chain of subspaces of V fixed under X */

PInvariantFlag := function (V, X)

    F := BaseRing (X);
    p := #F;
    d := Degree (X);
    MA := MatrixAlgebra (F, d);
    t := Ngens (X);
    Y := [MA!X.j : j in [1..t]];
/* the coercion of the generators of the p-group into the matrix algebra */

    /* clumsy handling of trivial case */
    if t eq 0 then
       B := Basis (V);
       d := #B;
       W := [sub < V | [B[j] : j in [i..d]]> : i in [1..d]];
/* take the set of subspaces to be those generated by the last (d-i) vectors
of V */
       Append (~W, sub < V | >);
    else
       W := [V]; // W starts a list containing just the whole space
       k := 1;
       I := Identity (MA);
       while Dimension (W[k]) ne 0 do
          k +:= 1;
          W[k] := &+[W[k-1] * (Y[j] - I): j in [1..t]];
/* this line forms the next term in the sequence by taking the previous
space and multiplying
it by all the generators of the p-group minus the identity */

       end while;
    end if;

    flag := [];
    for i in [1..#W - 1] do
       F, phi := quo < W[i] | W[i + 1] >;
/* F is the quotient space and phi is the natural map. For example in the
trivial case, we go from a subspace
with n vectors over a subspace with n-1 vectors to the full vector space of
dimension 1. */

       BF := Basis (F);
       FB := [BF[j] @@ phi : j in [1..Dimension (F)]];
/* the pre-image of each basis vector back up in W[i] */
       flag cat:= FB; // adds FB to flag
    end for;

    Spaces := [sub < V | >] cat
            [sub <V | [flag[i]: i in [#flag..j by -1]]>: j in [#flag..1 by
-1]];
/* the collection of spaces made up of the last j vectors in flag. */
    Reverse (~Spaces);
/* reverses the order so that the full space is first and the empty space is
last. */

    CB := (GL (d, p) ! &cat[Eltseq (f): f in flag])^-1;
/* taking the vectors of flag and turning them into a matrix. E.g. [1, 0]
and [0, 1]
becomes the 2 by 2 identity matrix. */

    return flag, CB, Spaces;

end function;

/* return generating set which determines (decreasing) chief series
subs for matrix group S */

BaseForMatrixGroup := function (S, W, psi: Verify := true)

    if Type (S) eq GrpMat then
       d, F := BasicParameters (S);
    elif Ngens(S) gt 0 then
       d := Nrows (Rep (S));
       F := BaseRing (Parent (Rep (S)));
       S := sub < GL (d, F) | S >;
    else
       return [], [];
    end if;

    T, phi := PCGroup (S);
    /* the 2nd worst bottleneck */

    CS := ChiefSeries (T);
    t := NPCgens (T);
    gens := [CS[i].1 : i in [1..t]];
    X := [gens[i] @@ phi: i in [1..t]];
    if Verify then
       subs := [sub < S | [X[j] : j in [t..i by -1]]> : i in [t..1 by -1]];
       O := [#subs[i] : i in [1..#subs]];
       /* a bottleneck - can it be removed? */

       if #O gt 1 then
          assert {IsPrime (O[i + 1] div O[i]) : i in [1..#O - 1]} eq {true};
          assert {IsNormal (S, subs[i]) : i in [1..#O - 1]} eq {true};
       end if;
    end if;
    XSLP := [X[i] @@ psi: i in [1..#X]];

    return X, sub <GL(d, F) | X>, XSLP;

end function;

/* the depth of u - u * g. If we have the zero vector, [Degree(u)+1, 1] is
returned. */

RelativeVectorDepth := function (u, g)
    d := DepthPlus(u - u * g);
return d[1] eq 0 select [Degree(u) + 1, 1] else d;
/* if the left hand side is true, do the first else do the second */

end function;

/* p is the characteristic of the field, u is a vector that we are
canonising, i is a pair representing the depth of u-u*h, h is the generator
of the p-group with minimal weight with respect to u, k is some other
generator of the p-group with weight greater than that of h. The function
returns the integer that makes u-u*k*h^alpha have greater depth than u-u*k.
*/

FindMultiple := function (p, u, i, k, h)

    beta := 0;
    v0 := (u - u*k*h) - (u - u*k);
    a := Eltseq(v0[i[1]])[i[2]];
    b := Eltseq((u - u*k)[i[1]])[i[2]];
    beta := -b/a;

    if beta notin PrimeField(GF(p)) then error "error in FindMultiple";
end if;
    beta := IntegerRing()!beta;

    return beta;

end function;

/* depths is the list of depths of basis vectors for U, p is the
characteristic of the field, u is the vector we are canonising, i is a pair
telling you the weight of u with respect to h, h is the generator of the
p-group of least weight with respect to u, k is some other element of the
p-group, U is the subspace of the original subspace consisting of just the
so-far-canonised basis vectors. This function finds the integer alpha that
makes u-u*(k * h^alpha) have greater depth that u-u*k. */

BFindMultiple := function (depths, p, u, i, k, h, U)

/*
    F := BaseRing(u);
    _, incl:= VectorSpace(F, PrimeField(F));
    if exists (alpha) {alpha : alpha in [1..p - 1] |
       SubspaceDepth (depths, u - u * (k * h^alpha), U)[1] gt i[1]} eq false
then
    if exists (alpha) {alpha : alpha in [1..p - 1] | (SubspaceDepth (depths,
u - u * (k * h^alpha), U)[1] eq i[1] and SubspaceDepth (depths, u - u * (k *
h^alpha), U)[2] gt i[2])} eq false then
       error "error in FindMultiple";
    end if; end if;

    return alpha;

*/

    n := #depths - Dimension (U);
    w := u - u*k*h;

    depths2 := depths;
    temp := [];
    for i in [n+1..#depths] do
       temp[i] := depths[i][1];
    end for;
    depths := temp;

    BU := Basis(U);

    dw := DepthPlus(w);
    while dw[1] in depths do
       pos := Position (depths, dw[1]) - n;

/* pos is the position in the defined portion of the depths vector with depth equal to that of w.*/

       w := w - w[dw[1]] / BU[pos][dw[1]] * BU[pos];

/* in the above, w[dw[1]] is the first non zero entry in w and U[pos][dw[1]] 
is the first non zero entry in U[pos] since both have the same depth. Hence
this process kills the dw[1]-th position in w. */

       dw := DepthPlus(w);
    end while;

    v1 := u - u*k;
    v1 := EcheloniseVector(v1, depths2, U);
    v0 := w - v1;
    a := Eltseq(v0[i[1]])[i[2]];
    b := Eltseq(v1[i[1]])[i[2]];
    beta := -b/a;

    if beta notin PrimeField(GF(p)) then error "error in BFindMultiple";
end if;
    beta := IntegerRing()!beta;

    return beta;

end function;

/* The inputs of this vector are the characteristic of the field p, a vector
u, a generator of the p-group h and a pair i consisting of the depth of
u-u*h */

VectorMultiple := function (p, u, h, i)

    F := BaseRing(u);
    beta := 0;
    v0 := u*h - u;
    a := Eltseq(v0[i[1]])[i[2]];
    b := Eltseq(u[i[1]])[i[2]];
    beta := -b/a;

    if beta notin PrimeField(GF(p)) then error "error in VectorMultiple";
end if;
    beta := IntegerRing()!beta;
    u := u*(h^beta);

    return beta, u;
end function;

/* This function finds the power of a matrix h (a generator of the p-group)
that kills the (i[2]-1)-th power of the i[1]-th entry of the input vector u.
The other inputs: p is the characteristic of the field, depths is a list of
depths of the basis vectors of the full subspace we are canonising, i is a
pair consisting of the weight of h with respect to u (and is minimal amongst
all elements of X). */

SpaceMultiple := function (p, u, depths, subU, h, i)
    beta := 0; // the power of h is initially set to 0
    u := EcheloniseVector (u, depths, subU);

    temp := u * h;
    temp := EcheloniseVector (temp, depths, subU);
    u0 := temp - u;
    a := Eltseq(u0[i[1]])[i[2]];
    b := Eltseq(u[i[1]])[i[2]];
    beta := -b/a;

    if beta notin PrimeField(GF(p)) then error "error in SpaceMultiple";
end if;
    beta := IntegerRing()!beta;
    u := u*h^beta;
    u := EcheloniseVector (u, depths, subU);

    return beta, u; /* returns the required power of h that kills the
required entry in u and the vector u as deformed by h. */

end function;

/* return canonical v for the input vector u, an element x in the p-group
such that u * x = v, and the stabiliser in the p-group of v. X here is the
generators of the p-group in upper uni-triangular form */

VectorCF := function (X, XSLP, u)

    d := Degree (u); F := BaseRing (Parent (u));
    if #X eq 0 then
       return u, Identity (GL(d, F)), Identity(SLPGroup(0)), X;
    end if; // the trivial case

    p := #F;
    d := Nrows (X[1]); /* the dimension of the p-group */

    v := u;
    depth := [RelativeVectorDepth (v, g) : g in X]; /* calculating the
weight of each generator of the p-group with respect to v */

/* the following code fragment calculates the minimum entry in the above
vector */
    depth1 := [depth[x, 1] : x in [1..#depth]];
    j0 := Minimum (depth1);
    depth2 := [];
    for x in [1..#X] do
        if depth[x, 1] eq j0 then
           Append(~depth2, depth[x, 2]);
        end if;
    end for;
    j1 := Minimum (depth2);

    x := X[1]^0; /* the identity of the p-group */
    xslp := Identity(Parent(XSLP[1])); /* the identity of the SLP. */
    Y := X; /* we will be deforming X, so we will store it in Y. */
    YSLP := XSLP;

/* The following loop starts with the generator g in X of minimum weight
([j0, j1]) with respect to the vector that we wish to canonise. We find a
power of this matrix g that kills the coefficient of the (j1-1)-th power of
omega (the primitive element) in the j0-th position of v. We then consider
every other element of X. If the element x in X has depth [j0, j1], then x
is replaced by a power of g times x such that the new x has a depth greater
than [j0, j1]. g is then removed from X and the process is repeated until
every element of X has depth greater than [d, anything] or X becomes empty.
*/

    while (j0 lt d + 1) do
       g := X[Position (depth, [j0, j1])]; /* Position(depth, [j0, j1]) is
the smallest integer i s.t. depth[i] = [j0, j1] */
       gslp := XSLP[Position (depth, [j0, j1])];
       alpha, v := VectorMultiple (p, v, g, [j0, j1]); /* finding the power
alpha of g that kills the [j0, j1] position of v and performing this process
on v. */
       x := x * g^alpha; /* keeping track of the element that will do u * x
= v */
       xslp := xslp * gslp^alpha;
       Y := []; /* keeping track of all the adjusted elements of X */
       YSLP := [];
       for h in X do
          if h ne g then
             if RelativeVectorDepth (v, h) eq [j0, j1] then
                beta := FindMultiple (p, v, [j0, j1], h, g); /* finding the
power of g that will adjust h to give it a higher depth */
                hh := h * g^beta;
                hhslp := XSLP[Position(X, h)] * gslp^beta;
             else
                hh := h; /* those elements of X that are already of a higher
depth than g. */
                hhslp := XSLP[Position(X, h)];
             end if;
             Append (~Y, hh);
             Append (~YSLP, hhslp);
          end if;
       end for;
       X := Y;
       XSLP := YSLP;
       if #X eq 0 then break; end if;
       depth := [RelativeVectorDepth (v, g) : g in X]; /* we recalculate the
weights of each element of X with respect to v. */
       depth1 := [depth[x, 1] : x in [1..#depth]];
       j0 := Minimum (depth1);
       depth2 := [];
       for x in [1..#X] do
           if depth[x, 1] eq j0 then
              Append(~depth2, depth[x, 2]);
           end if;
       end for;
       j1 := Minimum (depth2);

    end while;

    return v, x, xslp, X, XSLP; /*  return the canonised vector, the element
that maps the input vector to the canonised one (and its slp equivalent) and
the stabiliser of v in the p-group (and its slp equivalent) */

end function;

/* The one dimensional subspace of U consisting of just the one canonised
vector is U_t. The following function has as input the full subspace UU
so-far-canonised, the full vector space V, the stabiliser X of U_i+1, the
depths of the so far canonised basis vectors in U and the index where
U_index+1 has been fully canonised and U_index is to be canonised. */

NextSubspaceCF := function (X, XSLP, V, UU, depths, index)

    U := Basis (UU); /* set U to be the unique echelonised basis of UU */
    d := Degree (UU); /* the length of the vectors in UU */
    p := #BaseRing (UU);
    t := #U;
    v := U[index]; /* the vector to be canonised with respect to the other
basis elements */
    subU := sub < V | [U[i] : i in [index + 1..t]]>; /* a subspace of U
consisting of all the so-far-canonised vectors. */

    depth := [SubspaceDepth (depths, v - v * g, subU) : g in X]; /*
calculating the subspace weight of v with respect to each g in X. */
/* the following code fragment determines the minimum entry in the above
depth vector */
    depth1 := [depth[x, 1] : x in [1..#depth]];
    j0 := Minimum (depth1);
    depth2 := [];
    for x in [1..#depth] do
        if depth[x, 1] eq j0 then
           Append(~depth2, depth[x, 2]);
        end if;
    end for;
    j1 := Minimum (depth2);

    x := X[1]^0; /* we start with the identity element */
    xslp := Identity(Parent(XSLP[1]));
    Y := X; /* as we will be altering X for the short term, we will store it
in Y for now and alter Y instead. */
    YSLP := XSLP;

/* The following loop starts with the generator g in X of minimum weight
([j0, j1]) with respect to the vector that we wish to canonise. We find a
power of this matrix g that kills the coefficient of the (j1-1)-th power of
omega (the primitive element) in the j0-th position of v. We then consider
every other element of X. If the element x in X has depth [j0, j1], then x
is replaced by a power of g times x such that the new x has a depth greater
than [j0, j1]. g is then removed from X and the process is repeated until
every element of X has depth greater than [d, anything] or X becomes empty.
*/
    while (j0 lt d + 1) do
       g := X[Position (depth, [j0, j1])]; /* the element of X with depth
[j0, j1] */
       gslp := XSLP[Position (depth, [j0, j1])];
       v := EcheloniseVector (v, depths, subU); /* unsure why we are
echelonizing the vector, it works without this. */
       alpha, v := SpaceMultiple (p, v, depths, subU, g, [j0, j1]); /*
returns the power of g that kills the necessary part of v and the
appropriately altered v. */
       x := x * g^alpha; /* keep a note of what's been done in x */
       xslp := xslp * gslp^alpha;
       Y := []; /* we will now multiply each element of X by a power of g
such that each element now has weight with respect to v greater than that of
g. */
       YSLP := [];
       for h in X do
          if h ne g then
             if SubspaceDepth (depths, v - v * h, subU) eq [j0, j1] then
                beta := BFindMultiple (depths, Factorisation(p)[1][1], v,
[j0, j1], h, g, subU); /* finds the power of g needed to make h have a
greater depth than g. */
                hh := h * g^beta;
                hhslp := XSLP[Position(X, h)] * gslp^beta;
             else
                hh := h; /* for those elements of X that already have depth
greater than g. */
                hhslp := XSLP[Position(X, h)];
             end if;
             Append (~Y, hh);
             Append (~YSLP, hhslp);
          end if;
       end for;
       X := Y;
       XSLP := YSLP;
       if #X eq 0 then break; end if; /* if X is now empty, we are done */
       depth := [SubspaceDepth (depths, v - v * g, subU) : g in X]; /*
calculating the new depth vector and finding the new minimal one. */
       depth1 := [depth[x, 1] : x in [1..#depth]];
       j0 := Minimum (depth1);
       depth2 := [];
       for x in [1..#depth] do
         if depth[x, 1] eq j0 then
           Append(~depth2, depth[x, 2]);
         end if;
       end for;
    j1 := Minimum (depth2);

    end while;

    UU := UU * x; /* modifying the full subspace by the matrix that
canonises the vector that you wished to canonise. */
    depths[index] := DepthPlus(v); /* add the depth of the canonised vector
to depths */

    return x, xslp, UU, depths, X, XSLP; /* return the element that maps the
old U to the new U, the new U, the list of depths of the basis vectors of U
and the stabiliser of U in the p-group. */

end function;

/* determine canonical form for U under action of X;
    return canonical form UC, element trans where U^trans = UC,
    and stabiliser in X of UC. The X that is inputted here is the
upper-unitriangularized generating set for the original p-group and U is the
similarly altered version of the original subspace. */

SubspaceCF := function (X, XSLP, U)

    d := Degree (U); F := BaseRing (U);

    /* the trivial cases */
    if #X eq 0 then
        return U, Identity (GL(d, F)), Identity(Parent(XSLP[1])), X, XSLP;
    end if;
    if Dimension(U) eq 0 then
        return U, Identity (GL(d, F)), Identity(Parent(XSLP[1])), X, XSLP;
    end if;

    V := VectorSpace (F, d);

    UB := Basis (U); /* the unique echelonized basis for U. */
    t := #UB;
    CF, trans, transslp, X, XSLP := VectorCF (X, XSLP, UB[t]); /* finds the
canonical form for the last basis vector of U and reduces X to the
stabilizer of this vector in U. */
    U := U * trans; /* multiply by trans to canonize the last basis vector
*/
    UB := Basis (U);
    depths := []; /* we will now construct a list of the depths of the
canonised basis vectors. Not yet canonised implies that the corresponding
entry remains undefined. */
    depths[t] := DepthPlus (UB[t]); /* setting the last entry of the depths
vector to the depth of the canonised basis vector. So it looks like this:
[undef, undef, ..., undef, DepthsPlus(UB[t])]. */

/* The one dimensional subspace of U consisting of just the one canonised
vector is U_t. The following loop, at each iteration, inputs the full
subspace U so-far-canonised, the full vector space V, the stabiliser X of
U_i+1, the depths of the so far canonised basis vectors in U and the index i
where U_i+1 has been fully canonised and U_i is to be canonised. */
    for i in [t - 1..1 by -1] do
       if #X eq 0 then break; end if;
       temp, tempslp, U, depths, X, XSLP := NextSubspaceCF (X, XSLP, V, U,
depths, i);
/* the output here is the full vector space U with one extra basis vector
canonised, depths has been incremented by one value (the depth of the newly
canonised basis vector), X is the stabiliser of the so-far-canonised U in
the p-group */
       trans *:= temp; /* the matrix that sends the original U to the
canonised-so-far U */
       transslp *:= tempslp;
    end for;

    return U, trans, transslp, X, XSLP;

end function;

/* S is a p-group; U is a subspace of natural module;
    return canonical form UC for U, matrix trans where
    U^trans = UC, and generators for stabiliser in S of UC;

    if ComputeBase is false, we assume that the generators
    of S are a decreasing chief series for S */

PGroupStabiliser := function (S, U, W, psi: ComputeBase := ComputeBase)

    d := Degree (U); F := BaseRing (U);
    S := sub < GL (d, F) | S >; /* gets S as a subgroup of GL(d, F); unclear
as to why it needs to do this as S is already in this form. */
    if Ngens (S) eq 0 then return U, Identity (GL(d, F)),
Identity(W), S, 1; end if; /* the trivial case */

    if ComputeBase then
       _, S, XSLP := BaseForMatrixGroup (S, W, psi);
    else
       XSLP := [W.j : j in [1..Ngens(W)]];
    end if;

    V := VectorSpace (F, d);
    flag, CB := PInvariantFlag (V, S); /* CB is a change of basis matrix
that maps each element of S to one in upper unitriangular form */
    S := [S.i^CB : i in [1..Ngens (S)]]; /* making S the generating set of
old S in upper unitriangular form */
    CBinv := CB^-1;

    U := U^CB; /* times by CB to fall in line with S. */
    UC, trans, transslp, Y, YSLP := SubspaceCF (S, XSLP, U); /* input the
p-group and the subspace and get back out the canonicalized subspace, the
element that maps U to UC and the generators of the stabilizer of U in S. */
    p := #F; length := p^(#S - #Y);
    Trans := CB * trans; TransInv := Trans^-1;
    return UC^CBinv, Trans * CBinv, transslp, sub <GL (d, F) |
[Y[i]^TransInv : i in [1..#Y]]>, length; /* CBinv to un-upper-unitriangular
everything; the third return value is the stabiliser of U in the p-group-you
  transinv the generators to get the stabiliser of the original U as opposed
to UC. */

end function;

/* G is a p-group, U is a subspace of the vector space G acts on. This
returns the stabilizer of U in G (stab), a canonical form for U (cf) and an
element of G (trans) that maps U to cf. */

function UnipotentStabiliser (G, U: ComputeBase := true)

    W, psi := WordGroup(G);
    cf, trans, transslp, stab := PGroupStabiliser (G, U, W, psi: ComputeBase
:=
ComputeBase);
    return stab, cf, trans, transslp;

end function;






