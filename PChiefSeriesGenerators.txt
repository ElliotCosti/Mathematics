/* find increasing chain of subspaces of V fixed under X */

PInvariantFlag := function (V, X)

   F := BaseRing (X);
   q := #F;
   d := Degree (X);
   MA := MatrixAlgebra (F, d);
   t := Ngens (X);
   Y := [MA!X.j : j in [1..t]];

   /* clumsy handling of trivial case */
   if t eq 0 then
      B := Basis (V);
      d := #B;
      W := [sub < V | [B[j] : j in [i..d]]> : i in [1..d]];

      /* take the set of subspaces to be those generated by 
         the last (d-i) vectors of V */

      Append (~W, sub < V | >);
   else
      W := [V]; // W starts a list containing just the whole space
      k := 1;
      I := Identity (MA);
      while Dimension (W[k]) ne 0 do
         k +:= 1;
         W[k] := &+[W[k-1] * (Y[j] - I): j in [1..t]];
         /* this forms the next term in the sequence by taking the
            previous space and multiplying it by all the generators of the
            p-group minus the identity */

      end while;
   end if;

   flag := [];
   for i in [1..#W - 1] do
      F, phi := quo < W[i] | W[i + 1] >;

      /* F is the quotient space and phi is the natural map. For example in
         the trivial case, we go from a subspace with n vectors over a
         subspace with n-1 vectors to the full vector space of dimension 1. */

      BF := Basis (F);
      FB := [BF[j] @@ phi : j in [1..Dimension (F)]];

      /* the pre-image of each basis vector back up in W[i] */

      flag cat:= FB; // adds FB to flag
   end for;

   /* the collection of spaces made up of the last j vectors in flag. */
   Spaces := [sub < V | >] cat
      [sub <V | [flag[i]: i in [#flag..j by -1]]>: j in [#flag..1 by -1]];

   /* reverses the order so that the full space is first and the empty space
      is last. */
   Reverse (~Spaces);

   /* taking the vectors of flag and turning them into a matrix. E.g. [1, 0]
      and [0, 1] becomes the 2 by 2 identity matrix. */
   CB := (GL (d, q) ! &cat[Eltseq (f): f in flag])^-1;

   return flag, CB, Spaces;

end function;

/* Given a matrix M, and an integer j, take the jth diagonal above the
   leading diagonal of M and return it as a vector */

VectorExtract := function(j, M)
   n := Degree(M);
   F := BaseRing(M);
   v := [M[i, i+j] : i in [1..n-j]];
   v := VectorSpace(F, n-j)!v;
   return v;
end function;

/* Given an upper uni-triangular matrix M, determine its weight. The weight
   of a matrix in this sense is a triple. The first entry in the triple is the
   first diagonal (say D) above the leading diagonal that contains a non-zero
   entry. The second entry in the triple is the index of the first non-zero
   entry as you look down D. The third entry is the first non-zero coefficient
   of the first non-zero entry of D considered as a polynomial over the
   primitive element. */

MatrixWeight := function(M)

   n := Degree(M);

   k := 0;
   for z in [1..n-1] do
      for i in [1..n-z] do
         if M[i, i+z] ne 0 then k := z; break z; end if;
      end for;
   end for;
   if k eq 0 then return [n, 1, 1]; end if;

   F := BaseRing(M);
   v := VectorExtract(k, M);
   d := Depth(v);
   V := VectorSpace(F, PrimeField(F));
   dd := Depth(V!Eltseq(v[d]));
   return [k, d, dd];

end function;

/* given the weight of h (equal to that of s), find the power of s
   needed to increase the matrix weight of h. */

FindIncreasePower := function(weight, h, s)

   j0 := weight[1];
   j1 := weight[2];
   j2 := weight[3];

   alpha := -Eltseq(h[j1, j0 + j1])[j2]/Eltseq(s[j1, j0 + j1])[j2];
   alpha := IntegerRing()!alpha;

   return alpha;

end function;

/* S is a list of generators for the p-group, SSLP is a list giving
   each generator as an SLP, s is the element of S that you are about
   to remove and are using to multiply the other elements of S in order
   to give them higher matrix weight. min is the matrix weight of s. */

IncreaseDepthPair := function(s, S, SSLP, min)
   j0 := min[1];
   j1 := min[2];
   j2 := min[3];
   identity := Id(Parent(s[1]));
   X := [];
   XSLP := [];
   POSs := Position(S, s);
   for h in S do
      if h[1] ne s[1] then
         if h[2] eq [j0, j1, j2] then
            beta := FindIncreasePower ([j0, j1, j2], h[1], s[1]);
            v := h[1] * s[1]^beta;
            hh := <v, MatrixWeight(v)>;
            hhslp := SSLP[Position(S, h)] * SSLP[POSs]^beta;
         else
            hh := h;
            hhslp := SSLP[Position(S, h)];
         end if;
         if hh[1] ne identity then
            Append (~X, hh);
            Append (~XSLP, hhslp);
         end if;
      end if;
   end for;

   return X, XSLP;

end function;

/* return generating set which determines (decreasing) chief series
   subs for unipotent group X. If straight is set to true, an SLP
   for each new generator in terms of the input generators is also
   returned. */

PChiefSeriesGenerators := function(X: straight := false)

   if Ngens(X) eq 0 then
      if straight then return [], [];
      else return X; end if;
   end if;

   W := WordGroup(X);
   d := Dimension(X);
   F := BaseRing(X);
   identity := Id(X);
   flag, CB := PInvariantFlag (VectorSpace(F, d), X);
   X := [X.i^CB : i in [1..Ngens (X)]];

   B := [];
   BSLP := [];
   p := Characteristic(F);

   depth := [MatrixWeight(g) : g in X];
   Y := [<X[i], depth[i]> : i in [1..#X]];
   YSLP := [W.i : i in [1..#X]];
   XSLP := YSLP;

   depth1 := [depth[x, 1] : x in [1..#depth]];
   j0 := Minimum (depth1);
   depth2 := [];
   for x in [1..#X] do
      if depth[x, 1] eq j0 then
         Append(~depth2, depth[x, 2]);
      end if;
   end for;
   j1 := Minimum (depth2);
   depth3 := [];
   for x in [1..#X] do
      if (depth[x, 1] eq j0) and (depth[x, 2] eq j1) then
         Append(~depth3, depth[x, 3]);
      end if;
   end for;
   j2 := Minimum (depth3);

   while #Y ne 0 do
      pos := Position (depth, [j0, j1, j2]);
      g := Y[pos];
      gslp := YSLP[pos];
      Append(~B, g[1]);
      Append(~BSLP, gslp);

      Y, YSLP := IncreaseDepthPair(g, Y, YSLP, [j0, j1, j2]);

      v := g[1]^p;
      if v ne identity then
         Append(~Y, <v, MatrixWeight(v)>);
         Append(~YSLP, gslp^p);
      end if;
      for x in X do
         v := (g[1], x);
         if v ne identity then
            Append(~Y, <v, MatrixWeight(v)>);
            xslp := XSLP[Position(X, x)];
            Append(~YSLP, (gslp, xslp));
         end if;
      end for;

      if #Y eq 0 then break; end if;

      depth := [Y[j, 2] : j in [1..#Y]];
      depth1 := [depth[x, 1] : x in [1..#depth]];
      j0 := Minimum (depth1);
      depth2 := [];
      for x in [1..#Y] do
         if depth[x, 1] eq j0 then
            Append(~depth2, depth[x, 2]);
         end if;
      end for;
      j1 := Minimum (depth2);
      depth3 := [];
      for x in [1..#Y] do
         if (depth[x, 1] eq j0) and (depth[x, 2] eq j1) then
            Append(~depth3, depth[x, 3]);
         end if;
      end for;
      j2 := Minimum (depth3);

   end while;

   B := [B[i]^(CB^-1) : i in [1..#B]];

   if straight then
      return B, BSLP;
   else
      return B;
   end if;

end function;