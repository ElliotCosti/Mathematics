/* The inputs are G, a special linear group and A, an element of G.
   The algorithm returns the identity of G and A as an SLP in the
   generators of G as defined in the file standard.m. We return the
   identity element of G as a test to see if the programme has been
   successful. For other classical groups, inputting an element of
   GL(d, q) that does not preserve the required form will result in
   the algorithm failing to return the identity. By looking at the
   matrix that is returned, a user can assess how incorrect their
   choice of input matrix was.
*/

WordInGen := function(G, A)
   
   W := SLPGroup(4);
   d := Dimension(G);
   SS := SLPGroup(4);
   if d eq 1 then
      return A, SS!1;
   end if;
   
   /* When the code was originally written, it was written to a
      different generating set. This homomorphism maps the function to
      the new generating set.
   */
   if d eq 3 then
      phi := hom<SS -> W|W.4, W.3, W.1^-1, W.2>;
   else 
      phi := hom<SS -> W|W.4, W.3, W.1^-1, W.2^-1>;
   end if;
   
   F := BaseRing(G);
   w := PrimitiveElement(F);
   e := Degree(F);
   p := Characteristic(F);
   Z := IntegerRing();
   M := KMatrixSpace(F, d, d);
   
   /* We wish to find the matrix whose top row is [1 w 0 .. 0], has 1s  
      on the leading diagonal and 0s everywhere else. We construct the 
      subfield FF of F generated by w^2. This subfield has order
      greater than half of the order of F and hence is equal to F. By
      then coercing w into FF, magma will write w as a polynomial py in
      powers of the generator of FF. So w is written as a polynomial in
      w^2. t^(delta^-1) gives us the matrix with [1 w^2 0 .. 0] on the
      top row and t^(delta^-a) gives you the matrix with [1 w^2a 0 ..
      0] on the top row. Hence, you can use py to find the powers of
      t^(delta^-1) needed to give the matrix with [1 w 0 .. 0] on the
      top row.
   */
   
   FF := sub<F|w^2>;
   /* FF.1 eq (F.1)^2;
      this will be true due to above comment */
   py := FF!F.1;
   
   /* py is now a polynomial in w^2 that is equal to w */
   
   // O := Id(G);
   OO := Id(SS);
   for i in [1..e] do
      // O := O*(t^delta^-(i-1))^Z!Eltseq(py)[i];
      OO := OO*(SS.2^SS.1^-(i-1))^Z!Eltseq(py)[i];
   end for;
   
   S1 := SS!1;
   S2 := SS!1;
   
   /* this procedure is used to add row 1 to row j */
   
   RowOp := procedure(i, j, ~A, ~S, r)
   
   if r eq 1 then
      S := (SS.2^(SS.3*((SS.4*SS.3)^(j-i-1))*(SS.4^(i-1))))
         ^Z!Eltseq(A[j][i])[r]*S;
      /* aa := (t^(u*((v*u)^(j-i-1))*(v^(i-1))))
         ^Z!Eltseq(A[j][i])[r]*A;
      */
      AddRow(~A, -Eltseq(A[j][i])[r], i, j);
      /* only works when i < j - which is the only direction we ever  
         need
      */
   end if;
   
   if IsEven(r) then
      S := (((OO^(SS.1^-((r-2) div 2)))^(SS.3*((SS.4*SS.3)^(j-i-1))*(SS.4^(i-1)))))
         ^Z!Eltseq(A[j][i])[r]*S;
      /* aa := (((O^(delta^-((r-2) div 2)))^(u*((v*u)^(j-i-1))*(v^(i-1)))))
         ^Z!Eltseq(A[j][i])[r]*A; */
      AddRow(~A, -Eltseq(A[j][i])[r] * w^(r-1), i, j);
   end if;
   
   if IsOdd(r) then
      S := ((SS.2^(SS.1^-((r-1) div 2)))^(SS.3*((SS.4*SS.3)^(j-i-1))*(SS.4^(i-1))))
         ^Z!Eltseq(A[j][i])[r]*S;
      /* aa := ((t^(delta^-((r-1) div 2)))^(u*((v*u)^(j-i-1))*(v^(i-1))))
         ^Z!Eltseq(A[j][i])[r]*A; */
      AddRow(~A, -Eltseq(A[j][i])[r] * w^(r-1), i, j);
   end if;
   
   end procedure;
   
   ColOp := procedure(i, j, ~A, ~S, r)
   
   if r eq 1 then
      S := S*(SS.2^(((SS.4*SS.3)^(j-i-1))*(SS.4^(i-1))))^-Z!Eltseq(A[i][j])[r];
      /* aa := A*(t^(((v*u)^(j-i-1))*(v^(i-1))))^-Z!Eltseq(A[i][j])[r]; */
      AddColumn(~A, -Eltseq(A[i][j])[r], i, j);
   end if;
   
   if IsEven(r) then
      S := S*((OO^(SS.1^-((r-2) div 2)))^(((SS.4*SS.3)^(j-i-1))*(SS.4^(i-1))))
         ^-Z!Eltseq(A[i][j])[r];
      /* aa := A*((O^(delta^-((r-2) div 2)))^(((v*u)^(j-i-1))*(v^(i-1))))
         ^-Z!Eltseq(A[i][j])[r]; */
      AddColumn(~A, -Eltseq(A[i][j])[r] * w^(r-1), i, j);
   end if;
   
   if IsOdd(r) then
      S := S*((SS.2^(SS.1^-((r-1) div 2)))^(((SS.4*SS.3)^(j-i-1))*(SS.4^(i-1))))
         ^-Z!Eltseq(A[i][j])[r];
      /* aa := A*((t^(delta^-((r-1) div 2)))^(((v*u)^(j-i-1))*(v^(i-1))))
         ^-Z!Eltseq(A[i][j])[r]; */
      AddColumn(~A, -Eltseq(A[i][j])[r] * w^(r-1), i, j);
   end if;
   
   end procedure;
   
   /* A*(v^-1) puts the first column to the back, shuffles each column 
      left one and negates all the others; A*((v^-1)^k) where k is
      even, puts the first k columns to the back and negates them
      whilst shifting all the others to the left A*((v^-1)^k) where k
      is odd, puts the first k columns to the back and negates all the
      OTHER columns whilst shifting these others to the left
   */
   
   /* this procedure has the effect of conjugating by v^-1 */
   
   ConjByVInverse := procedure(~A, n);
   
      B := Transpose(A);
      C := ZeroMatrix(F, d, d);
      for i in [1..d-n] do
         C[i] := IsEven(n) select B[i+n] else -B[i+n];
      end for;
      for i in [1..n] do
         C[d-n+i] := IsEven(n) select -B[i] else B[i];
      end for;
   
      A := Transpose(C);
   
      C := ZeroMatrix(F, d, d);
      for i in [1..d-n] do
         C[i] := IsEven(n) select A[i+n] else -A[i+n];
      end for;
      for i in [1..n] do
         C[d-n+i] := IsEven(n) select -A[i] else A[i];
      end for;
   
      A := C;
   
   end procedure;
   
   /* A*v brings the last column to the front, shuffles each other row
      right one place whilst negating them A*((v^-1)^k) where k is
      even, brings the last k columns to the front and negates them
      whilst shifting all the others to the right A*((v^-1)^k) where k
      is odd, brings the last k columns to the front and negates all
      the OTHER columns whilst shifting these others to the right v^-1
      * A brings the bottom row to the top, shuffles each other row 
      down one place whilst negating them
   */
   
   ConjByV := procedure(~A, n);
   
      B := Transpose(A);
      C := ZeroMatrix(F, d, d);
      for i in [1..n] do
         C[i] := IsEven(n) select -B[d-n+i] else B[d-n+i];
      end for;
      for i in [1..d-n] do
         C[n+i] := IsEven(n) select B[i] else -B[i];
      end for;
   
      A := Transpose(C);
   
      C := ZeroMatrix(F, d, d);
      for i in [1..n] do
         C[i] := IsEven(n) select -A[d-n+i] else A[d-n+i];
      end for;
      for i in [1..d-n] do
         C[n+i] := IsEven(n) select A[i] else -A[i];
      end for;
   
      A := C;
   
   end procedure;
   
   A := M!A;
   
   for k in [0..d-2] do
   
   /* A := A^((v^-1)^k);
     moves the first, second, ..., kth column and row out of the way.
   */
   ConjByVInverse(~A, k);
   
   S1 := (SS.4)^k*S1;
   S2 := S2*((SS.4^-1)^k);
   
   /* we now proceed to get a 1 in the top left hand corner of the
      matrix A
   */
   
   if A[1, 1] eq 0 then
   i := Depth(A[1]);
   /* A := A*(u*v^-1)^(i-2)*(u*v)^(i-2)*u; */

   /* swaps column 1 with column i whilst negating every column between
      1 and i exclusive. In the special case i = 2, the negation is
      only applied to column 1. This will never move any columns that
      have already been done because they will always contain a 0 in
      the first row at this stage.
   */

   A := SwapColumns(A, 1, i);
   if i ne 2 then
      for j in [2..(i-1)] do
         MultiplyColumn(~A, -1, j);
      end for;
   else
      MultiplyColumn(~A, -1, 2);
   end if;
   if IsEven(i) and i ne 2 then
      MultiplyColumn(~A, -1, i);
   end if;
   
   S2 := S2*(SS.3*SS.4^-1)^(i-2)*(SS.3*SS.4)^(i-2)*SS.3;
   end if;
   
   if A[1, 1] ne 1 then
      i := 2;
      if {A[i, 1] eq 0 : i in [2..d]} eq {true} then
         /* A := A*(t^u); */
         /* this subtracts column 2 from column 1 and is necessary if
            the column has zeroes in every position as else we will not
            be able to subsequently add a multiple of one row to the
            top row in order to get a 1 in the [1, 1] position.
         */
         AddColumn(~A, -1, 2, 1);
         S2 := S2*(SS.2^SS.3);
      end if;
      while A[i, 1] eq 0 do
         i +:= 1;
      end while;
   
      /* we now subtract a suitable multiple (BB) of the i-th row to
         the first to get a 1 in the [1, 1] entry
      */
      BB := (A[1, 1]-1)/A[i, 1];
      // T := t^-1;
      TT := SS.2^-1;
      // T := (T^(((v*u)^(i-2))))^Z!Eltseq(BB)[1];
      TT := (TT^(((SS.4*SS.3)^(i-2))))^Z!Eltseq(BB)[1];
      for r in [2..e] do
         if IsEven(r) then
            /* T := T*((((O^-1)^(delta^-((r-2) div 2)))^(((v*u)^(i-2))))^Z!Eltseq(BB)[r]); */
            TT := TT*((((OO^-1)^(SS.1^-((r-2) div 2)))^(((SS.4*SS.3)^(i-2))))^Z!Eltseq(BB)[r]);
         else
            /* T := T*((((t^-1)^(delta^-((r-1) div 2)))^(((v*u)^(i-2))))^Z!Eltseq(BB)[r]); */
            TT := TT*((((SS.2^-1)^(SS.1^-((r-1) div 2)))^(((SS.4*SS.3)^(i-2))))^Z!Eltseq(BB)[r]);
         end if;
      end for;
   // A := T*A;
   AddRow(~A, -BB, i, 1);
   S1 := TT*S1;
   end if;
      
   for j in [2..d-k] do
      for r in [1.. e] do
         RowOp(1, j, ~A, ~S1, r);
      end for;
   end for;
   
   for j in [2..d-k] do
      for r in [1.. e] do
         ColOp(1, j, ~A, ~S2, r);
      end for;
   end for;
   
   /* A := A^(v^k);
      moves the rows and columns back to their original position */
   ConjByV(~A, k);
   
   S1 := ((SS.4^-1)^k)*S1;
   S2 := S2*(SS.4^k);
   
   end for;
   
   word := (S1^-1*S2^-1);
   word := phi(word);
   
   return A, word;
   
end function;
   
/* Having completed the above, the A[d, d] entry should now be 1 too
   since the matrix will now have 1s along the main diagonal, zeroes
   everywhere else and the matrix must have determinant 1.
*/
   
