Hi Charles,

I've gone through the C_p wreath C_p example to see what happens with the code. We were looking at the point of the algorithm where you throw the commutators in and you noticed that instead of inserting [g, X, ..., X], I was only inserting [g, X], where X generates the p-group and g is the element of minimal weight.

I believe that it does not matter which way you do it.

Consider the example that we spoke about: G := C_3 wr C_3. This is generated by <a, b> where a is the little cycle and b is the bigger cycle. These matrices are made upper unitriangular and then passed to the part of the algorithm that will turn Y = {a, b} into a chief series.

b is of least weight so this is chosen first. We are putting the generators into a set B, which is currently empty. At the end of each while loop, B and Y will look like this:

B = {}, Y = {a, b}
B = {b}, Y = {a, [b, a]}
B = {b, a}, Y = {[b, a], [a, b]}
B = {b, a, [b, a]}, Y = {[b, a, b]}
B = {b, a, [b, a], [b, a, b]}, Y = {}.

B here preserves the required chief series even though we have only be considering [g, X] and not [g, X, ..., X] at each stage. This is because [g, X, ..., X] is still computed, but it doesn't happen all at once at the same point of the algorithm. Instead it happens in bits. In fact, for the above example the following were calculated:

[b, a], [b, b], [a, a], [a, b], [b, a, a], [b, a, b], [a, b, a], [a, b, b].

I also tried this for C_7 wr C_7 and C_3 wr C_3 wr C_3 and I the answers matched once again. I have kept both versions of the code.

Does this do more to convince you that the original code is correct? If not, are you happy that all the current proof needs is a tweak so that  [g, X, ..., X] is being looked at rather than just [g, X]?

Perhaps we should meet up again to discuss this in person.

Elliot