CreateGenerators := function(G)

// We now create the four generators. u, the two cycle; v, the n cycle
// t an element that adds row / column 1 to row / column 2
// delta, a generator to make the group over a prime power. 

F := BaseRing (G);
w := PrimitiveElement (F);
d := Dimension(G);
if d ne 2 then error "The dimension of G must be 2."; end if;
M := KMatrixSpace(F, d, d); 
b := Basis(M);

t := M!Id(G) + b[2]; 
t := G!t; 
delta := M!Id(G) -b[1] -b[d+2] + w*b[1] + (w^-1)*b[d+2]; 
delta := G!delta;
r := M!Id(G) + b[3]; 
r := G!r;

return [delta, t, r];

end function;

WordInGen := function(G, A, SSS) 

d := Dimension(G); 
if d ne 2 then error "The dimension of G must be 2."; end if;

SS := [SSS.3, SSS.2, SSS.1];

F := BaseRing(G);
w := PrimitiveElement (F);
e := Degree(F);
p := Characteristic(F);
Z := IntegerRing();
M := KMatrixSpace(F, d, d);


/* We wish to find the matrix whose top row is [1 w 0 .. 0], has 1s on the leading diagonal and 0s everywhere else. We construct the subfield FF of F generated by w^2. This is equal to F. By then coercing w into FF, magma will write w as a polynomial py in powers of the generator of FF. So w is written as a polynomial in w^2. t^(delta^-1) gives us the matrix with [1 w^2 0 .. 0] on the top row and t^(delta^-a) gives you the matrix with [1 w^2a 0 .. 0] on the top row. Hence, you can use py to find the powers of t^(delta^-1) needed to give the matrix with [1 w 0 .. 0] on the top row.

*/

FF := sub<F|w^2>;
// FF.1 eq (F.1)^2; <- this will be true
py := FF!F.1;

/*py is now a polynomial in w^2 that is equal to w*/

// O := Id(G);
OO := Id(SSS);
for i in [1..e] do
   // O := O*(t^delta^-(i-1))^Z!Eltseq(py)[i];
   OO := OO*(SS[2]^SS[1]^-(i-1))^Z!Eltseq(py)[i];
end for;

// OR := Id(G);
OOR := Id(SSS);
for i in [1..e] do
   // OR := OR*(r^delta^(i-1))^Z!Eltseq(py)[i];
   OOR := OOR*(SS[3]^SS[1]^(i-1))^Z!Eltseq(py)[i];
end for;

S1 := Id(SSS);
S2 := Id(SSS);

/* this procedure is used to add row i=1 to row j=2 */

RowOp := procedure(i, j, ~A, ~S, rr) 

if rr eq 1 then 
   S := SS[3]^-Z!Eltseq(A[2][1])[1]*S;
   // aa := r^-Z!Eltseq(A[2][1])[1]*A;
   AddRow(~A, -Eltseq(A[2][1])[1], 1, 2);
end if;

if IsEven(rr) then
   S := (OOR^(SS[1]^((rr-2) div 2)))^-Z!Eltseq(A[j][i])[rr]*S;
   // aa := (OR^(delta^((rr-2) div 2)))^-Z!Eltseq(A[j][i])[rr]*A;
   AddRow(~A, -Eltseq(A[2][1])[rr] * w^(rr-1), i, j);
end if; 

if IsOdd(rr) then 
   S := (SS[3]^(SS[1]^((rr-1) div 2)))^-Z!Eltseq(A[j][i])[rr]*S;
   // aa := (r^(delta^((rr-1) div 2)))^-Z!Eltseq(A[j][i])[rr]*A;
   AddRow(~A, -Eltseq(A[2][1])[rr] * w^(rr-1), i, j);
end if;

end procedure; 

ColOp := procedure(i, j, ~A, ~S, rr) 

if rr eq 1 then 
   S := SS[2]^-Z!Eltseq(A[1][2])[rr]*S;
   // aa := t^-Z!Eltseq(A[1][2])[rr]*A;
   AddColumn(~A, -Eltseq(A[1][2])[rr], 1, 2);
end if;

if IsEven(rr) then
   S := (OO^(SS[1]^-((rr-2) div 2)))^-Z!Eltseq(A[1][2])[rr]*S;
   // aa := (O^(delta^-((rr-2) div 2)))^-Z!Eltseq(A[1][2])[rr]*A;
   AddColumn(~A, -Eltseq(A[1][2])[rr] * w^(rr-1), i, j);
end if; 

if IsOdd(rr) then 
   S := (SS[2]^(SS[1]^-((rr-1) div 2)))^-Z!Eltseq(A[1][2])[rr]*S;
   // aa := (t^(delta^-((rr-1) div 2)))^-Z!Eltseq(A[1][2])[rr]*A;
   AddColumn(~A, -Eltseq(A[1][2])[rr] * w^(rr-1), i, j);
end if;

end procedure; 

A := M!A; 

// file 2 takes as input the random element A and gets 1 in the (1, 1) entry. 

/* we now proceed to get a 1 in the top left hand corner of the matrix A */

if A[1, 1] eq 0 then 
   // A := t*A;
   AddRow(~A, 1, 2, 1);
   S1 := SS[2]*S1;
end if;

if A[1, 1] ne 1 then
   i := 2; 
   if A[2, 1] eq 0 then
      // A := r*A;
      AddRow(~A, 1, 1, 2);
      S1 := SS[3]*S1;
   end if;
   
   /* we now subtract a suitable multiple (BB) of the i-th row to the first to get a 1 in the [1, 1] entry */
   BB := (A[1, 1]-1)/A[2, 1];
   // T := t^-1;
   TT := SS[2]^-1;
   // T := T^Z!Eltseq(BB)[1];
   TT := TT^Z!Eltseq(BB)[1];
   for rr in [2..e] do
      if IsEven(rr) then 
         // T := T*(((O^-1)^(delta^-((rr-2) div 2)))^Z!Eltseq(BB)[rr]); 
         TT := TT*(((OO^-1)^(SS[1]^-((rr-2) div 2)))^Z!Eltseq(BB)[rr]);
      else  
         // T := T*(((t^-1)^(delta^-((rr-1) div 2)))^Z!Eltseq(BB)[rr]); 
         TT := TT*(((SS[2]^-1)^(SS[1]^-((rr-1) div 2)))^Z!Eltseq(BB)[rr]);
      end if;
   end for;
// A := T*A;
AddRow(~A, -BB, 2, 1);
S1 := TT*S1;
end if;

for rr in [1.. e] do // needs to go up to the power of the characteristic of the field 
   RowOp(1, 2, ~A, ~S1, rr); 
end for;  

for rr in [1.. e] do 
   ColOp(1, 2, ~A, ~S2, rr);
end for; 

return A, (S1^-1*S2^-1); 

end function; 


// Having completed the above, the A[d, d] entry should now be 1 too since the matrix will now have 1s along the main diagonal, zeroes everywhere else and the matrix must have determinant 1.

