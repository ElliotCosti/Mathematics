SLChosenElements := function (G )

   d := Degree (G);
   F := BaseRing (G); 

   w := PrimitiveElement (F);
   M := MatrixAlgebra (F, d);
   a := Identity (M);
   a[1][1] := 0;
   a[1][2] := 1;
   a[2][1] := -1;
   a[2][2] := 0;

   b := Zero (M);
   for i in [2..d] do
      b[i][i - 1] := -1;
   end for;
   b[1][d] := 1;
   if d eq 3 then b := b^-1; end if;
 
   t := Identity (M);
   t[1][2] := 1;

   delta := Identity (M);
   delta[1][1] := w;
   delta[2][2] := w^-1;

   P := GL(d, F);
   a := P!a; b := P!b; t := P!t; delta := P!delta;

   return [a, b, t, delta];
 
end function;

/* The inputs are G, a special linear group and A, an element of G.
   The algorithm returns the identity of G and A as an SLP in the
   generators of G as defined in the file standard.m. We return the
   identity element of G as a test to see if the programme has been
   successful. For other classical groups, inputting an element of
   GL(d, q) that does not preserve the required form will result in
   the algorithm failing to return the identity. By looking at the
   matrix that is returned, a user can assess how incorrect their
   choice of input matrix was.
*/

WordInGen := function(G, A)
   
   W := SLPGroup(4);
   d := Dimension(G);
   SS := SLPGroup(4);
   if d eq 1 then
      return A, SS!1;
   end if;
   
   /* When the code was originally written, it was written to a
      different generating set. This homomorphism maps the function to
      the new generating set.
   */
   if d eq 3 then
      phi := hom<SS -> W|W.4, W.3, W.1^-1, W.2>;
   else 
      phi := hom<SS -> W|W.4, W.3, W.1^-1, W.2^-1>;
   end if;
   
   F := BaseRing(G);
   w := PrimitiveElement(F);
   e := Degree(F);
   p := Characteristic(F);
   Z := IntegerRing();
   M := KMatrixSpace(F, d, d);
   
   /* We wish to find the matrix whose top row is [1 w 0 .. 0], has 1s  
      on the leading diagonal and 0s everywhere else. We construct the 
      subfield FF of F generated by w^2. This subfield has order
      greater than half of the order of F and hence is equal to F. By
      then coercing w into FF, magma will write w as a polynomial py in
      powers of the generator of FF. So w is written as a polynomial in
      w^2. t^(delta^-1) gives us the matrix with [1 w^2 0 .. 0] on the
      top row and t^(delta^-a) gives you the matrix with [1 w^2a 0 ..
      0] on the top row. Hence, you can use py to find the powers of
      t^(delta^-1) needed to give the matrix with [1 w 0 .. 0] on the
      top row.
   */
   
   FF := sub<F|w^2>;
   /* FF.1 eq (F.1)^2;
      this will be true due to above comment */
   py := FF!F.1;
   
   /* py is now a polynomial in w^2 that is equal to w */
   
   // O := Id(G);
   OO := Id(SS);
   for i in [1..e] do
      // O := O*(t^delta^-(i-1))^Z!Eltseq(py)[i];
      OO := OO*(SS.2^SS.1^-(i-1))^Z!Eltseq(py)[i];
   end for;
   
   S1 := SS!1;
   S2 := SS!1;
   
   /* this procedure is used to add row 1 to row j */
   
   RowOp := procedure(i, j, ~A, ~S, r)
   
   if r eq 1 then
      S := (SS.2^(SS.3*((SS.4*SS.3)^(j-i-1))*(SS.4^(i-1))))
         ^Z!Eltseq(A[j][i])[r]*S;
      /* aa := (t^(u*((v*u)^(j-i-1))*(v^(i-1))))
         ^Z!Eltseq(A[j][i])[r]*A;
      */
      AddRow(~A, -Eltseq(A[j][i])[r], i, j);
      /* only works when i < j - which is the only direction we ever  
         need
      */
   end if;
   
   if IsEven(r) then
      S := (((OO^(SS.1^-((r-2) div 2)))^(SS.3*((SS.4*SS.3)^(j-i-1))*(SS.4^(i-1)))))
         ^Z!Eltseq(A[j][i])[r]*S;
      /* aa := (((O^(delta^-((r-2) div 2)))^(u*((v*u)^(j-i-1))*(v^(i-1)))))
         ^Z!Eltseq(A[j][i])[r]*A; */
      AddRow(~A, -Eltseq(A[j][i])[r] * w^(r-1), i, j);
   end if;
   
   if IsOdd(r) then
      S := ((SS.2^(SS.1^-((r-1) div 2)))^(SS.3*((SS.4*SS.3)^(j-i-1))*(SS.4^(i-1))))
         ^Z!Eltseq(A[j][i])[r]*S;
      /* aa := ((t^(delta^-((r-1) div 2)))^(u*((v*u)^(j-i-1))*(v^(i-1))))
         ^Z!Eltseq(A[j][i])[r]*A; */
      AddRow(~A, -Eltseq(A[j][i])[r] * w^(r-1), i, j);
   end if;
   
   end procedure;
   
   ColOp := procedure(i, j, ~A, ~S, r)
   
   if r eq 1 then
      S := S*(SS.2^(((SS.4*SS.3)^(j-i-1))*(SS.4^(i-1))))^-Z!Eltseq(A[i][j])[r];
      /* aa := A*(t^(((v*u)^(j-i-1))*(v^(i-1))))^-Z!Eltseq(A[i][j])[r]; */
      AddColumn(~A, -Eltseq(A[i][j])[r], i, j);
   end if;
   
   if IsEven(r) then
      S := S*((OO^(SS.1^-((r-2) div 2)))^(((SS.4*SS.3)^(j-i-1))*(SS.4^(i-1))))
         ^-Z!Eltseq(A[i][j])[r];
      /* aa := A*((O^(delta^-((r-2) div 2)))^(((v*u)^(j-i-1))*(v^(i-1))))
         ^-Z!Eltseq(A[i][j])[r]; */
      AddColumn(~A, -Eltseq(A[i][j])[r] * w^(r-1), i, j);
   end if;
   
   if IsOdd(r) then
      S := S*((SS.2^(SS.1^-((r-1) div 2)))^(((SS.4*SS.3)^(j-i-1))*(SS.4^(i-1))))
         ^-Z!Eltseq(A[i][j])[r];
      /* aa := A*((t^(delta^-((r-1) div 2)))^(((v*u)^(j-i-1))*(v^(i-1))))
         ^-Z!Eltseq(A[i][j])[r]; */
      AddColumn(~A, -Eltseq(A[i][j])[r] * w^(r-1), i, j);
   end if;
   
   end procedure;
   
   /* A*(v^-1) puts the first column to the back, shuffles each column 
      left one and negates all the others; A*((v^-1)^k) where k is
      even, puts the first k columns to the back and negates them
      whilst shifting all the others to the left A*((v^-1)^k) where k
      is odd, puts the first k columns to the back and negates all the
      OTHER columns whilst shifting these others to the left
   */
   
   /* this procedure has the effect of conjugating by v^-1 */
   
   ConjByVInverse := procedure(~A, n);
   
      B := Transpose(A);
      C := ZeroMatrix(F, d, d);
      for i in [1..d-n] do
         C[i] := IsEven(n) select B[i+n] else -B[i+n];
      end for;
      for i in [1..n] do
         C[d-n+i] := IsEven(n) select -B[i] else B[i];
      end for;
   
      A := Transpose(C);
   
      C := ZeroMatrix(F, d, d);
      for i in [1..d-n] do
         C[i] := IsEven(n) select A[i+n] else -A[i+n];
      end for;
      for i in [1..n] do
         C[d-n+i] := IsEven(n) select -A[i] else A[i];
      end for;
   
      A := C;
   
   end procedure;
   
   /* A*v brings the last column to the front, shuffles each other row
      right one place whilst negating them A*((v^-1)^k) where k is
      even, brings the last k columns to the front and negates them
      whilst shifting all the others to the right A*((v^-1)^k) where k
      is odd, brings the last k columns to the front and negates all
      the OTHER columns whilst shifting these others to the right v^-1
      * A brings the bottom row to the top, shuffles each other row 
      down one place whilst negating them
   */
   
   ConjByV := procedure(~A, n);
   
      B := Transpose(A);
      C := ZeroMatrix(F, d, d);
      for i in [1..n] do
         C[i] := IsEven(n) select -B[d-n+i] else B[d-n+i];
      end for;
      for i in [1..d-n] do
         C[n+i] := IsEven(n) select B[i] else -B[i];
      end for;
   
      A := Transpose(C);
   
      C := ZeroMatrix(F, d, d);
      for i in [1..n] do
         C[i] := IsEven(n) select -A[d-n+i] else A[d-n+i];
      end for;
      for i in [1..d-n] do
         C[n+i] := IsEven(n) select A[i] else -A[i];
      end for;
   
      A := C;
   
   end procedure;
   
   A := M!A;
   
   for k in [0..d-2] do
   
   /* A := A^((v^-1)^k);
     moves the first, second, ..., kth column and row out of the way.
   */
   ConjByVInverse(~A, k);
   
   S1 := (SS.4)^k*S1;
   S2 := S2*((SS.4^-1)^k);
   
   /* we now proceed to get a 1 in the top left hand corner of the
      matrix A
   */
   
   if A[1, 1] eq 0 then
   i := Depth(A[1]);
   /* A := A*(u*v^-1)^(i-2)*(u*v)^(i-2)*u; */

   /* swaps column 1 with column i whilst negating every column between
      1 and i exclusive. In the special case i = 2, the negation is
      only applied to column 1. This will never move any columns that
      have already been done because they will always contain a 0 in
      the first row at this stage.
   */

   A := SwapColumns(A, 1, i);
   if i ne 2 then
      for j in [2..(i-1)] do
         MultiplyColumn(~A, -1, j);
      end for;
   else
      MultiplyColumn(~A, -1, 2);
   end if;
   if IsEven(i) and i ne 2 then
      MultiplyColumn(~A, -1, i);
   end if;
   
   S2 := S2*(SS.3*SS.4^-1)^(i-2)*(SS.3*SS.4)^(i-2)*SS.3;
   end if;
   
   if A[1, 1] ne 1 then
      i := 2;
      if {A[i, 1] eq 0 : i in [2..d]} eq {true} then
         /* A := A*(t^u); */
         /* this subtracts column 2 from column 1 and is necessary if
            the column has zeroes in every position as else we will not
            be able to subsequently add a multiple of one row to the
            top row in order to get a 1 in the [1, 1] position.
         */
         AddColumn(~A, -1, 2, 1);
         S2 := S2*(SS.2^SS.3);
      end if;
      while A[i, 1] eq 0 do
         i +:= 1;
      end while;
   
      /* we now subtract a suitable multiple (BB) of the i-th row to
         the first to get a 1 in the [1, 1] entry
      */
      BB := (A[1, 1]-1)/A[i, 1];
      // T := t^-1;
      TT := SS.2^-1;
      // T := (T^(((v*u)^(i-2))))^Z!Eltseq(BB)[1];
      TT := (TT^(((SS.4*SS.3)^(i-2))))^Z!Eltseq(BB)[1];
      for r in [2..e] do
         if IsEven(r) then
            /* T := T*((((O^-1)^(delta^-((r-2) div 2)))^(((v*u)^(i-2))))^Z!Eltseq(BB)[r]); */
            TT := TT*((((OO^-1)^(SS.1^-((r-2) div 2)))^(((SS.4*SS.3)^(i-2))))^Z!Eltseq(BB)[r]);
         else
            /* T := T*((((t^-1)^(delta^-((r-1) div 2)))^(((v*u)^(i-2))))^Z!Eltseq(BB)[r]); */
            TT := TT*((((SS.2^-1)^(SS.1^-((r-1) div 2)))^(((SS.4*SS.3)^(i-2))))^Z!Eltseq(BB)[r]);
         end if;
      end for;
   // A := T*A;
   AddRow(~A, -BB, i, 1);
   S1 := TT*S1;
   end if;
      
   for j in [2..d-k] do
      for r in [1.. e] do
         RowOp(1, j, ~A, ~S1, r);
      end for;
   end for;
   
   for j in [2..d-k] do
      for r in [1.. e] do
         ColOp(1, j, ~A, ~S2, r);
      end for;
   end for;
   
   /* A := A^(v^k);
      moves the rows and columns back to their original position */
   ConjByV(~A, k);
   
   S1 := ((SS.4^-1)^k)*S1;
   S2 := S2*(SS.4^k);
   
   end for;
   
   word := (S1^-1*S2^-1);
   word := phi(word);
   
   return A, word;
   
end function;
   
/* Having completed the above, the A[d, d] entry should now be 1 too
   since the matrix will now have 1s along the main diagonal, zeroes
   everywhere else and the matrix must have determinant 1.
*/

   /* creating H. H is the subgroup of G that fixes the first basis
      element of the natural module. As this has a p-local subgroup, it
      affords a 1-dimensional submodule in the natural dimension.
   */


intrinsic GetU(E::GrpMat, Q::SeqEnum, d::RngIntElt, qq::RngIntElt) -> ModTupFld, ModTupFld
{Returns two submodules};

   q := #BaseRing(Q[1]);
   F := GF(q);
   w := PrimitiveElement(GF(qq));
   M := KMatrixSpace(GF(qq), d, d);
   b := Basis(M);
   G := SL(d, qq);
   n := Degree(Q[1]);

   if assigned E`Module then
      return E`Module;
   end if;

   if d gt 2 then
      QG := SLChosenElements(SL(d-1, qq));
   else;
      small := SL(1, qq)![1];
      QG := [small, small, small, small];
   end if;

/*   HQ := [G!InsertBlock(Id(G), QG[i], 2, 2) : i in [1..#QG]];
   Htt := M!Id(G) + b[d+1]; Htt := G!Htt;
   Append(~HQ, Htt);
   Hplus := M!Id(G) -b[1] -b[d+2] + w*b[1] + (w^-1)*b[d+2];
     Hplus := G!Hplus;
*/
   /* the element that will make H q^(d-1):GL(d, q) as opposed to
      q^(d-1):SL(d, q) */
/*   Append(~HQ, Hplus); */

   u := Q[1];
   v := Q[2];
   t := Q[3];
   delta := Q[4];

   if d ne 3 then
      HEQ := [u^(v^-1), u^-1 * v, t^(v^-1), delta^(v^-1), (t^u)^(-1),
      delta];
   else
      HEQ := [u^v, u^v, t^v, delta^v, (t^u)^(-1), delta];
   end if;

   if d eq 2 then
      HEQ := [(t^v)^-1, delta];
   end if;

   /* H := sub<GL(d, qq)|HQ>;
      H here is q^(d-1):GL(d, q) and q^(d-1) is the normal p-sg */

   /* we now map H to the non-natural representation. */

/*   HEQ := [];
   for i in [1..#HQ] do
      _, word := WordInGen(G, HQ[i]);
      Append(~HEQ, Evaluate(word, Q));
   end for;
*/

   HE := sub<GL(n, q)| HEQ>;
   /* is reducible as it contains a p-local subgroup */
   VPH := GModule(HE);

   /* U is a non-trivial submodule */
   _, U := IsIrreducible(VPH);

   V := VectorSpace(GF(q), n);
   U1 := sub<V|[V!VPH!U.i : i in [1..Dimension(U)]]>;
   /* Here U has been rewritten in vectors of length n but
      the module still has its original dimension
   */

   Remove(~HEQ, #HEQ - 1);
   Htt := M!Id(G) + b[2]; Htt := G!Htt;
   _, Htt1 := WordInGen(G, Htt);
   Append(~HEQ, Evaluate(Htt1, Q));
   
   HE2 := sub<GL(n, q)|HEQ>;
   VPH2 := GModule(HE2);
   _, U := IsIrreducible(VPH2);
   U2 := sub<V|[V!VPH2!U.i : i in [1..Dimension(U)]]>;

   E`Module := [U1, U2];
   return E`Module;

end intrinsic;


   /* Function that returns the transvection with omega in the
      (1, 2) place
   */

GetO := function(Q, d, qq)

   q := #BaseRing(Q[1]);
   F := GF(qq);
   w := PrimitiveElement(GF(qq));
   t := Q[3];
   delta := Q[4];
   Z := IntegerRing();
   e := Factorization(qq)[1][2];

   FF := sub<F|w^2>;
   py := FF!F.1;
   
   /* py is now a polynomial in w^2 that is equal to w */
   
   O := Id(Parent(Q[1]));
   for i in [1..e] do
      O := O*(t^delta^-(i-1))^Z!Eltseq(py)[i];
   end for;

   return O;

end function;


   /* we now create an elementary abelian p-group K. The generators of
      K consist of those elements with some power of the primitive
      element in the top row (excluding the first position), 1s down
      the leading diagonal and 0s everywhere else
   */

intrinsic GetK(E::GrpMat, Q::SeqEnum, d::RngIntElt, qq::RngIntElt) -> SeqEnum, SeqEnum
{Returns the image of the p-groups under the representation};

   q := #BaseRing(Q[1]);
   F := GF(q);
   w := PrimitiveElement(GF(qq));
   M := KMatrixSpace(GF(qq), d, d);
   b := Basis(M);
   G := SL(d, qq);
   n := Degree(Q[1]);

   if assigned E`PG1 then
      return E`PG1, E`PG2, E`PG3;
   end if;

   e := Factorization(qq)[1][2];
   S := [];
   for j in [1..e] do
      for i in [2..d] do
         Append(~S, SL(d, qq)!(M!Id(G) + (w^(j-1))*b[i]));
      end for;
   end for;

   /* K := sub<SL(d, qq)|gg>;
      Isomorphic to (C_q)^(d-1) */

   /* mapping K to the non-natural representation */

   /*
   kk := [];
   for i in [1..#S] do
      _, word := WordInGen(G, S[i]);
      Append(~kk, Evaluate(word, Q));
   end for;
   */

   u := Q[1];
   if d ne 3 then
      v := Q[2];
   else
      v := Q[2]^-1;
   end if;
   t := Q[3];
   delta := Q[4];
   O := GetO(Q, d, qq);

   kk := [];
   for j in [1..e] do
      if IsOdd(j) then
         T := t^(delta^-((j-1) div 2));
         kk := kk cat [T^((u*v)^-i) : i in [0..d-2]];
      else
         T := O^(delta^-((j-1) div 2));
         kk := kk cat [T^((u*v)^-i) : i in [0..d-2]];
      end if;
   end for;

   KE := sub<GL(n, q)|[kk[i] : i in [1..#kk]]>;

   S1 := [Transpose(S[i]) : i in [1..#S]];
   /* K1 := sub<SL(d, q)|S1>; */

   /*
   kk2 := [];
   for i in [1..#S1] do
      _, word := WordInGen(G, S1[i]);
      Append(~kk2, Evaluate(word, Q));
   end for;
   */

   kk2 := [];
   for j in [1..e] do
      if IsOdd(j) then
         T := (t^u)^-1;
         T := T^(delta^((j-1) div 2));
         kk2 := kk2 cat [T^((u*v)^-i) : i in [0..d-2]];
      else
         T := (O^u)^-1;
         T := T^(delta^((j-1) div 2));
         kk2 := kk2 cat [T^((u*v)^-i) : i in [0..d-2]];
      end if;
   end for;
   KE2 := sub<GL(n, q)|kk2>;

   E`PG1 := [KE, KE2];
   E`PG2 := kk;
   E`PG3 := [S, S1];
   return E`PG1, E`PG2, E`PG3;

end intrinsic;